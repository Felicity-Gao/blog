# 功能辨析
## 1. 计算属性 vs 方法
```js
// 计算属性
computed: {
    reversedMessage: function () {
      return this.message.split('').reverse().join('')
    }
  }
// 方法
methods: {
  reversedMessage: function () {
    return this.message.split('').reverse().join('')
  }
}
```
在组件中调用方法可以达到跟`computed`相同的效果。但是，**计算属性是基于它们的响应式依赖进行缓存的**。即：只有当`message`发生改变时，计算属性中的`reversedMessage`函数才会重新调用，只要`message`还没有发生改变，多次访问`reversedMessage`计算属性会立即返回之前的计算结果，而不必再次执行函数。这样相比方法的每次调用大大的提高了效率。
## 2. 计算属性 vs 侦听属性
当需要侦听多个属性的变化来更改某个属性时，计算属性比侦听属性很多，写起来也简洁很多。如下面的要求：当 lastName 和 firstName 改变的时候更新 fullName 。
```js
//  侦听属性写法
watch: {
    firstName: function (val) {
      this.fullName = val + ' ' + this.lastName
    },
    lastName: function (val) {
      this.fullName = this.firstName + ' ' + val
    }
  }
  // 计算属性写法
  computed: {
    fullName: function () {
      return this.firstName + ' ' + this.lastName
    }
  }
```
但是当需要在数据变化时执行异步或开销较大的操作时，就只能使用`watch`。`watch`选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。

vm.$watch 返回一个取消观察函数，用来停止触发回调：
```js
var unwatch = vm.$watch('a', cb)
// 之后取消观察
unwatch()
```
> tips：为了发现对象内部值的变化，可以在选项参数中指定 `deep: true`。注意监听数组的变更不要这么做。

> tips：在选项参数中指定 `immediate: true` 将立即以表达式的当前值触发回调。注意在带有 `immediate` 选项时，你不能在第一次回调时`取消侦听`给定的 property。