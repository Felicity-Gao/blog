# 父子组件间事件的传递
## 1. $emit
父级组件可以像处理 `native DOM` 事件一样通过`v-on`监听子组件实例的任意事件, 同时子组件可以通过调用内建的`$emit`方法并传入事件名称来触发一个事件，有了这个 `v-on:enlarge-text="postFontSize += 0.1"` 监听器，父级组件就会接收该事件并更`postFontSize `的值
```html
<!-- 父组件中的子组件 -->
<son v-on:enlarge-text="postFontSize += $event"></son>

<!-- 子组件 -->
<button v-on:click="$emit('enlarge-text', 0.1)">
  按钮
</button>
```
或者，如果这个事件处理函数是一个方法，那么这个值将会作为第一个参数传入这个方法：
```js
<son v-on:enlarge-text="onEnlargeText"></son>

// 父组件中的方法 event就是子组件中第二个参数传入的值
methods: {
  onEnlargeText: function (event) {
    this.postFontSize += event
  }
}
```
## 2. v-model
自定义事件也可以用于创建支持 `v-model` 的自定义输入组件。记住：
```html
<input v-model="searchText">
```
等价于：
```html
<input
  v-bind:value="searchText"
  v-on:input="searchText = $event.target.value"
>
```
当用在组件上时，v-model 则会这样：
```html
<custom-input
  v-bind:value="searchText"
  v-on:input="searchText = $event"
></custom-input>
```
为了让它正常工作，这个组件内的`<input>`必须：

1. 将其 `value` attribute 绑定到一个名叫 `value` 的 `prop` 上
2. 在其 `input` 事件被触发时，将新的值通过自定义的 `input` 事件抛出
写成代码之后是这样的：
```js
Vue.component('custom-input', {
  props: ['value'],
  template: `
    <input
      v-bind:value="value"
      v-on:input="$emit('input', $event.target.value)"
    >
  `
})
```
现在 v-model 就应该可以在这个组件上完美地工作起来了：
```html
<custom-input v-model="searchText"></custom-input>
```
一个组件上的 `v-model` 默认会利用名为`value`的 `prop` 和名为 `input` 的事件，但是像单选框、复选框等类型的输入控件可能会将 `value attribute` 用于不同的目的。model 选项可以用来避免这样的冲突：
```js
Vue.component('base-checkbox', {
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    checked: Boolean
  },
  template: `
    <input
      type="checkbox"
      v-bind:checked="checked"
      v-on:change="$emit('change', $event.target.checked)"
    >
  `
})
```
现在在这个组件上使用 v-model 的时候：
```html
<base-checkbox v-model="lovingVue"></base-checkbox>
```
这里的 `lovingVue` 的值将会传入这个名为 `checked` 的 `prop`。同时当 `<base-checkbox>` 触发一个 `change` 事件并附带一个新的值的时候，这个 `lovingVue` 的 `property` 将会被更新。

## 3. $listeners 与 $attrs
**$attrs：** 包含了父作用域中不作为 prop 被识别 (且获取) 的 `attribute` 绑定 (class 和 style 除外)。当一个组件没有声明任何 `prop` 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 `v-bind="$attrs"` 传入内部组件。

**$listeners：** 包含了父作用域中的(不含 .native 修饰器的)`v-on`事件监听器。它可以通过`v-on="$listeners"`传入内部组件。


你可能有很多次想要在一个组件的根元素上直接监听一个原生事件。这时，你可以使用 v-on 的 .native 修饰符,在有的时候这是很有用的，不过在你尝试监听一个类似 `<input>` 的非常特定的元素时，这并不是个好主意。比如上述 `<base-input>` 组件可能做了如下重构，所以根元素实际上是一个 `<label>` 元素：
```html
<label>
  {{ label }}
  <input
    v-bind="$attrs"
    v-bind:value="value"
    v-on:input="$emit('input', $event.target.value)"
  >
</label>
```

这时，父级的 `.native` 监听器将静默失败。它不会产生任何报错，但是 `onFocus` 处理函数不会如你预期地被调用。为了解决这个问题，Vue 提供了一个 `$listeners` property，它是一个对象，里面包含了作用在这个组件上的所有监听器。例如：
```js
{
  focus: function (event) { /* ... */ }
  input: function (value) { /* ... */ },
}
```
有了这个 $listeners property，你就可以配合 v-on="$listeners" 将所有的事件监听器指向这个组件的某个特定的子元素。对于类似 `<input>` 的你希望它也可以配合 v-model 工作的组件来说，为这些监听器创建一个类似下述 inputListeners 的计算属性通常是非常有用的.
## 4. `.sync`修饰符
如果直接对一个子组件中`props`进行双向数据绑定的话，容易造成混乱：

1. 不知道哪一步子组件的操作，连带着造成父组件变量的变更，导致定位问题比较难；
2. 不太容易知道是子组件的更改还是父组件自己的更改，造成混乱

所以Vue推荐使用`update:myPropName`来人为标记需要双向绑定的`props`。
```js
//  子组件中发射变更的值
this.$emit('update:title', newTitle)

// 父组件中接收并会在data中更新
<text-document
  v-bind:title="doc.title"
  v-on:update:title="doc.title = $event"
></text-document>
```
为了方便起见，我们为这种模式提供一个缩写，即 `.sync` 修饰符：
```html
<text-document v-bind:title.sync="doc.title"></text-document>
```