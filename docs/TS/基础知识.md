# 基础知识
## 类型
类型除了基础的`string`，`number`，`Array<>`或`类型[]`，`boolean`,Object外还有一些组合类型：
1. 交叉类型(&): `&`连接的类型必须都有；
2. 联合类型（|）：`｜`连接的类型至少有一个

### 1. 类型别名（type）
如果某些`类型组合`会在一些地方经常用到，就可以把它提取出来，作为一个固定的自定义类型来调用。声明方式与变量的声明方式类似，只要把`const``let`换成`type`就可以。
```js
type Alias = T | U
```
```js
type InnerType = 'default' | 'primary' | 'danger'

interface Button {
  type: InnerType
  text: string
}
```

### 2. 类型索引（keyof）
`keyof` 类似于 `Object.keys` ，用于获取一个接口中 Key 的联合类型。
```js
interface Button {
    type: string
    text: string
}

type ButtonKeys = keyof Button
// 等效于
type ButtonKeys = "type" | "text"
```
用法： 当你的一个类中某个字段的类型依赖于某个接口的类型
```js
interface ButtonStyle {
    color: string
    background: string
}
interface ButtonTypes {
    default: ButtonStyle
    primary: ButtonStyle
    danger: ButtonStyle
}
interface Button {
    type: 'default' | 'primary' | 'danger'
    text: string
}

// 使用 keyof 后，ButtonTypes修改后，type 类型会自动修改 
interface Button {
    type: keyof ButtonTypes
    text: string
}
```
当`ButtonTypes`的类型增减的时候，`Button`的`type`类型会动态增减。优化了代码，在`ButtonTypes`，减少的时候不会有冗余类型，又在其增加的时候不需要手动增加类型，可以动态的读取。

### 3. 类型约束（extends）
这里的 `extends` 关键词不同于在 `class` 后使用 `extends` 的继承作用，泛型内使用的主要作用是对泛型加以约束。
```js
type BaseType = string | number | boolean

// 这里表示 copy 的参数只能是字符串、数字、布尔这几种基础类型
function copy<T extends BaseType>(arg: T): T {
  return arg
}
```
当你传入`BaseType`规定的类型以外的类型的话，ts就会报错。